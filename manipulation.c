#pragma config(Sensor, dgtl1,  button,         sensorTouch)
#pragma config(Sensor, dgtl2,  elbowEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  shoulderEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  ,               sensorSONAR_cm)
#pragma config(Sensor, dgtl8,  shoulderLimit,  sensorTouch)
#pragma config(Motor,  port2,           shoulder,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           elbow,         tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define SHOULDER_SPEED 80
#define ELBOW_SPEED 20
#define SHOUDLER_MAX_ANGLE -70

/*
 * Test Function
 */
void changeState(int state) {
	if (state == 0) {
		motor[shoulder] = SHOULDER_SPEED;
	} else if (state == 1) {
		motor[shoulder] = -SHOULDER_SPEED;
	} else if (state == 2) {
		motor[shoulder] = 0;
	} else if (state == 3) {
		motor[elbow] = ELBOW_SPEED;
	} else if (state == 4) {
		motor[elbow] = -ELBOW_SPEED;
	} else if (state == 5) {
		motor[elbow] = 0;
	} else if (state == 6) {
		motor[shoulder] = motor[elbow] = 0;
	}
	// Test Functionality (PUT IN MAIN)
	//if (SensorValue(button) == 1) {
	//	state += 1;
	//	state %= 7;
	//	changeState(state);
	//	wait1Msec(200);
	//}
}

void forwardShoulder() {
	motor[shoulder] = SHOULDER_SPEED;
}

void reverseShoulder() {
	motor[shoulder] = -SHOULDER_SPEED;
}

void forwardElbow() {
	motor[elbow] = ELBOW_SPEED;
}

void reverseElbow() {
	motor[elbow] = -ELBOW_SPEED;
}

void stopShoulder() {
	motor[shoulder] = 0;
}

void stopElbow() {
	motor[elbow] = 0;
}

void stopMovement() {
	stopShoulder();
	stopElbow();
}

task main()
{
	// VARIABLES
	int TARGET_SHOULDER_ANGLE = 0;
	int TARGET_ELBOW_ANGLE = 0;
	int shoulderTravel = 0, elbowTravel = 0;

	// DEBUG SECTION
	/*while (true) {
		//motor[elbow] = -15;
		//motor[shoulder] = 45;
	}*/

	//----------------------------------
	// DO NOT CHANGE - INITIAL CALIBRATION TO SAFE VALUES
	SensorValue[elbowEncoder] = 0;
	motor[shoulder] = SHOULDER_SPEED;
	while (true) {
		if (SensorValue(shoulderLimit) == 1) {
			stopMovement();
			wait1Msec(1000);
			SensorValue[shoulderEncoder] = 0;
			stopMovement();
			break;
		}
	}
	while (true) {
		shoulderTravel = SensorValue(shoulderEncoder);
		if (shoulderTravel > -45) {
			reverseShoulder();
		} else if (shoulderTravel < -45) {
			forwardShoulder();
		} else {
			stopMovement();
			break;
		}
	}
	//----------------------------------
	//----------------------------------
	//----------------------------------



	// MAIN LOOP
	// FIND, GRAB, DISPOSE cans
	while (true) {
		shoulderTravel = SensorValue(shoulderEncoder);
		elbowTravel = SensorValue(elbowEncoder);
		// SAFETY CHECK
		if (shoulderTravel < SHOUDLER_MAX_ANGLE + 1) {
			stopMovement();
			break;
		} else if (SensorValue(shoulderLimit) == 1) {
			reverseShoulder();
			wait1Msec(3000);
			stopMovement();
			break;
		}
		reverseShoulder();
		wait1Msec(2000);
		stopMovement();
		forwardElbow();
		wait1Msec(3000);
		stopMovement();
		break;

	}
	// END MAIN LOOP



	//----------------------------------
	//----------------------------------
	//----------------------------------
	// RETURN SHOULDER TO STARTING POSITION
	while (true) {
		shoulderTravel = SensorValue(shoulderEncoder);
		if (shoulderTravel > -45) {
			reverseShoulder();
		} else if (shoulderTravel < -45) {
			forwardShoulder();
		} else {
			stopMovement();
			break;
		}
	}
	// RETURN ELBOW TO STARTING POSITION
	while (true) {
		elbowTravel = SensorValue(elbowEncoder);
		if (elbowTravel > 0) {
			reverseElbow();
		} else if (elbowTravel < 0) {
			forwardElbow();
		} else {
			stopMovement();
			break;
		}
	}
	//----------------------------------
	//----------------------------------
	//----------------------------------
}
