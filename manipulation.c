#pragma config(Sensor, dgtl1,  button,         sensorTouch)
#pragma config(Sensor, dgtl2,  elbowEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  shoulderEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  ultra,               sensorSONAR_cm)
#pragma config(Sensor, dgtl8,  shoulderLimit,  sensorTouch)
#pragma config(Motor,  port2,           shoulder,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           elbow,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           claw,          tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define SHOULDER_SPEED 70
#define ELBOW_SPEED 40
#define SHOUDLER_MAX_ANGLE -70

/*
 * Test Function
 */
/*void changeState(int state) {
	if (state == 0) {
		motor[shoulder] = SHOULDER_SPEED;
	} else if (state == 1) {
		motor[shoulder] = -SHOULDER_SPEED;
	} else if (state == 2) {
		motor[shoulder] = 0;
	} else if (state == 3) {
		motor[elbow] = ELBOW_SPEED;
	} else if (state == 4) {
		motor[elbow] = -ELBOW_SPEED;
	} else if (state == 5) {
		motor[elbow] = 0;
	} else if (state == 6) {
		motor[shoulder] = motor[elbow] = 0;
	}
	// Test Functionality (PUT IN MAIN)
	//if (SensorValue(button) == 1) {
	//	state += 1;
	//	state %= 7;
	//	changeState(state);
	//	wait1Msec(200);
	//}
}*/

void openClaw() {
	motor[claw] = -127;
	wait1Msec(1000);
}

void closeClaw() {
	motor[claw] = 65;
	wait1Msec(1000);
}

void forwardShoulder() {
	motor[shoulder] = SHOULDER_SPEED;
}

void reverseShoulder() {
	motor[shoulder] = -SHOULDER_SPEED;
}

void forwardElbow() {
	motor[elbow] = ELBOW_SPEED;
}

void reverseElbow() {
	motor[elbow] = -ELBOW_SPEED;
}

void stopShoulder() {
	motor[shoulder] = 0;
}

void stopElbow() {
	motor[elbow] = 0;
}

void stopMovement() {
	stopShoulder();
	stopElbow();
}

void gotoo(int shoulderAngle, int elbowAngle) {
	int shoulderTravel = 0, elbowTravel = 0;
	bool elbowStopped = false, shoulderStopped = false;
	while (!elbowStopped | !shoulderStopped) {
		elbowTravel = SensorValue(elbowEncoder);
		shoulderTravel = SensorValue(shoulderEncoder);
		if (!elbowStopped) {
			if (elbowTravel > elbowAngle) {
				reverseElbow();
			} else if (elbowTravel < elbowAngle) {
				forwardElbow();
			} else {
				stopElbow();
				elbowStopped = true;
			}
		}
		if (!shoulderStopped) {
			if (shoulderTravel > shoulderAngle) {
				reverseShoulder();
			} else if (shoulderTravel < shoulderAngle) {
				forwardShoulder();
			} else {
				stopShoulder();
				shoulderStopped = true;
			}
		}
	}
	wait1Msec(500);
}

void reset() {
	openClaw();
	gotoo(-60,0);
}

void throwCan() {
	gotoo(-70,-40);
	openClaw();
	reset();
}

void grabCan() {
	int dist = SensorValue(ultra);
	// subtracting 6 from any equation
	if (dist < 6) {
		dist = 6;
	}
	openClaw();
	gotoo(-65 + ((dist - 6)*2),130 - ((dist - 6)*2));
	closeClaw();
	gotoo(-65 + ((dist - 6)*1) - 5,130 - ((dist - 6)*2));
	gotoo(-75,130);
	gotoo(-75,100);
	throwCan();
	wait1Msec(2000);
}

task main()
{
	// VARIABLES
	int shoulderTravel = 0, elbowTravel = 0;

	while (true) {
		// MANUAL CALIBRATION BLOCK
		/*while (true) {
			motor[elbow] = -20;
			motor[shoulder] = 50;
		}*/

		//----------------------------------
		// DO NOT CHANGE - INITIAL CALIBRATION TO SAFE VALUES
		/*SensorValue[elbowEncoder] = 0;
		// SET SHOULDER TO 0 BY CALIBRATING
		// COMMENT OUT IF ALREADY CALIBRATED
		motor[shoulder] = SHOULDER_SPEED;
		while (true) {
			if (SensorValue(shoulderLimit) == 1) {
				stopMovement();
				wait1Msec(1000);
				SensorValue[shoulderEncoder] = 0;
				stopMovement();
				gotoo(-45,0);
				break;
			}
		}*/
		//----------------------------------
		//----------------------------------
		//----------------------------------



		// MAIN LOOP
		// FIND, GRAB, DISPOSE cans
		while (true) {
			shoulderTravel = SensorValue(shoulderEncoder);
			elbowTravel = SensorValue(elbowEncoder);
			// SAFETY CHECK
			if (shoulderTravel < SHOUDLER_MAX_ANGLE + 1) {
				stopMovement();
				break;
			} else if (SensorValue(shoulderLimit) == 1) {
				reverseShoulder();
				wait1Msec(3000);
				stopMovement();
				break;
			}
			//gotoo(-80,0);
			reset();
			grabCan();
			grabCan();
			// RESET POSITION
			reset();
			wait1Msec(4000);
			break;
		}
		// END MAIN LOOP

		//----------------------------------
		//----------------------------------
		//----------------------------------
		wait1Msec(10000);
	}
}
