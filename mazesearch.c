#pragma config(Sensor, in1,    lightSensor,    sensorReflection)
#pragma config(Sensor, dgtl1,  sonarInput,     sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  leftBump,       sensorTouch)
#pragma config(Sensor, dgtl6,  rightBump,      sensorTouch)
#pragma config(Sensor, dgtl7,  startButton,    sensorTouch)
#pragma config(Motor,  port2,           rightMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           myServo,       tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define ServoWaitTime 750
#define nSamples 3
#define MotorTurnTime 710
#define ForwardTurn 65
#define BackwardTurn -55
#define MotorForwardTime 1000
#define MotorForwardSpeed 70
#define MotorReverseTime 800
#define MotorReverseSpeed -70
#define ForwardThresholdDistance 45
#define SideThresholdDistance 30

/*
 * stopMovement: sets the motion of the robot's wheels to zero
 * paramters: none
*/
void stopMovement() {
	motor[leftMotor] = motor[rightMotor] = 0;
}

/*
 * sampleDistance: samples nSamples times and returns the average reading
 * of the ultrasonic sensor
 * paramters: none
 * returns (int) avg / nSamples
 */
int sampleDistance() {
	int avg = 0;
	for (int i = 0; i < nSamples; i++) {
		avg += SensorValue(sonarInput); // Sample Sonar
	}
	return avg / nSamples;
}

/*
 * sampleLight: samples nSamples times and returns the average reading
 * of the light sensor
 * paramters: none
 * returns (int) avg / nSamples
*/
int sampleLight() {
	int avg = 0;
	for (int i = 0; i < nSamples; i++) {
		avg += SensorValue(lightSensor); // Sample Sonar
	}
	return avg / nSamples;
}

void findPath(int *distanceValue,int *distanceIndex, int *lightValue, int *lightIndex) {
	// Set servo to initial position and wait for it to get there
	motor[myServo] = -127;
	sleep(500);

	// Declare some variables for later
	int maxDistance = -1,maxDistanceIndex = NULL, minLightIndex = NULL;
	int minLight = 2000;
	int distance,light;
	// loop through possible positions for light sensor
	for (int i = -127; i < 128; i+=4) {
		// set position
		motor[myServo] = i;
		wait1Msec(50);
		// take reading
		distance = SensorValue(sonarInput);
		light = sampleLight();
		if (distance > maxDistance) {
			maxDistance = distance;
			maxDistanceIndex = i;
		}
		if (light < minLight) {
			minLight = light;
			minLightIndex = i;
		}
	}
	*distanceValue = maxDistance;
	*distanceIndex = maxDistanceIndex;
	*lightValue = minLight;
	*lightIndex = minLightIndex;
}

/*
 * sampleLimitValue: samples left and right limit switches
 * paramters: none
 * returns (int) 1 if either one is pressed
 * returns (int) 0 if they are not pressed
int sampleLimitValue() {
	int leftLimit = SensorValue(leftLimitSwitch);
	int rightLimit = SensorValue(rightLimitSwitch);

	if(rightLimit == 1 | leftLimit == 1) {
		return(1);
	}
	else {
		return(0);
	}
}
*/

/*
 * sampleBumpValue: samples left and right bump switches
 * paramters: none
 * returns (int) 1 if either one is pressed
 * returns (int) 0 if they are not pressed
*/
int sampleBumpValue() {
	int leftBump = SensorValue(leftBump);
	int rightBump = SensorValue(rightBump);

	if(rightBump == 1) {
		return 2;
	}
	else if (leftBump == 1) {
		return 1;
	} else {
		return 0;
	}
}


/*
 * lookRight: measure the distance to the right of the robot
 * by moving the light sensor via the servo assembly to the right
 * side of the robot and calling sampleDistance() to get a reading
 * from the ultrasonic sensor
 * paramters: none
 * returns (int) distance
*/
int lookRight() {
	// Variable Declarations
	int distance;

	// Functionality
	motor[myServo] = -127;
	wait1Msec(ServoWaitTime);
	distance = sampleDistance();
	motor[myServo] = 0;
	wait1Msec(ServoWaitTime);
	return distance;
}

/*
 * lookLeft: measure the distance to the right of the robot
 * by moving the light sensor via the servo assembly to the left
 * side of the robot and calling sampleDistance() to get a reading
 * from the ultrasonic sensor
 * paramters: none
 * returns (int) distance
*/
int lookLeft() {
	// Variable Declarations
	int distance;

	// Functionality
	motor[myServo] = 127;
	wait1Msec(ServoWaitTime);
	distance = sampleDistance();
	motor[myServo] = 0;
	wait1Msec(ServoWaitTime);
	return distance;
}

/*
 * lookFoward: measures the distance forward by first looking left
 * to calibrate the forward measurement and then resamples the distance
 * and returns that value
 * paramters: none
 * returns (int) distance
*/
int lookForward() {
	// Variable Declarations
	int distance;

	// Functionality
	distance = lookLeft();
	distance = sampleDistance();
	return distance;
}

/*
 * turnRight: sets the motion of the left motor to the constant
 * ForwardTurn and sets the motion of the right motor to BackwardTurn
 * and then stops motion by calling stopMovement()
 * paramters: none
*/
void turnRight() {
	motor[leftMotor] = ForwardTurn;
	motor[rightMotor] = BackwardTurn;
	wait1Msec(MotorTurnTime);
	stopMovement();
}

/*
 * turnLeft: sets the motion of the right motor to the constant
 * ForwardTurn and sets the motion of the left motor to BackwardTurn
 * and then stops motion by calling stopMovement()
 * paramters: none
*/
void turnLeft() {
	motor[leftMotor] = BackwardTurn;
	motor[rightMotor] = ForwardTurn;
	wait1Msec(MotorTurnTime);
	stopMovement();
}

/*
 * moveReverse: sets the motion of the robot to
 * the set MotorReverseSpeed constant for MotorReverseTime milliseconds
 * and then stops
 * paramters: none
*/
void moveReverse() {
	motor[leftMotor] = motor[rightMotor] = MotorReverseSpeed;
	wait1Msec(MotorReverseTime);
	stopMovement();
}

/*
 * moveForward: sets the motion of the robot to
 * the set MotorForwardSpeed constant for MotorForwardTime milliseconds
 * and then stops
 * paramters: none
*/void moveForward() {
	motor[rightMotor] = (int)((float)MotorForwardSpeed * 1.1);
	motor[leftMotor] = MotorForwardSpeed;
	wait1Msec(MotorForwardTime);
	int bump = sampleBumpValue();
	if (bump == 2) {
		writeDebugStream("right\n");
		// Turn Left
		moveReverse();
	} else if (bump == 1) {
		writeDebugStream("left\n");
		// Turn Right
		moveReverse();
	}
	stopMovement();
}

/*
void turnAround(int leftDistance, int rightDistance) {
	moveReverse();
	if (rightDistance > ThresholdDistance != leftDistance > ThresholdDistance) { // logical XOR
		if (rightDistance > ThresholdDistance) {
			turnRight();
		} else {
			turnLeft();
		}
	} else {
		// Turn Around
		if (rightDistance > leftDistance) {
			turnRight();
			sleep(100);
			turnRight();
		} else {
			turnLeft();
			sleep(100);
			turnLeft();
		}
	}
}
*/


task main()
{
	while (true) {
		while (SensorValue(startButton) != 1);
		wait1Msec(1000);
		//int distance, distanceIndex, light, lightIndex;
		moveForward();
		// Maze Search Algorithm
		while (true) {
			// Uncomment to test Calibration of ultrasonic sensor
			// and the right and left DC motors
			/*
			writeDebugStream("Right Distance: %d\n", lookRight());
			writeDebugStream("Front Distance: %d\n", lookForward());
			writeDebugStream("Left Distance: %d\n", lookLeft());
			sleep(3000);
			moveForward();
			wait1Msec(1000);
			turnLeft();
			wait1Msec(1000);
			turnRight();
			wait1Msec(1000);
			moveReverse();
			sleep(10000);
			//writeDebugStream("bumbPressed?: %d\n", sampleBumpValue());
			//writeDebugStream("limitPressed?: %d\n", sampleLimitValue());
			writeDebugStream("minIndexForLight: %d\n", findLight());
			//sleep(abs(lightPosition)*2); **Use this for findLight()**
			sleep(3000);
			*/
			// END CALIBRATION CODE
			/*if (SensorValue(leftLimitSwitch)) {
				moveReverse();
				moveReverse();
			}
			*/
			// Adjust position in chute
			int left = lookLeft();
			if (SensorValue(startButton) == 1) {
				break;
			}
			int right = lookRight();
			if (SensorValue(startButton) == 1) {
				break;
			}
			int forward = lookForward();
			if (SensorValue(startButton) == 1) {
				break;
			}
			if (forward < ForwardThresholdDistance && (left < SideThresholdDistance && right < SideThresholdDistance)) {
				turnLeft();
				turnLeft();
				moveForward();
			} else if (forward < ForwardThresholdDistance) {
				if (left > right) {
					turnLeft();
				} else {
					turnRight();
				}
				moveForward();
			} else if (abs(left-right) > 10) {
				if (left > right) {
					motor[leftMotor]  = 0;
		    	motor[rightMotor] = 75;
				} else {
					motor[leftMotor]  = 75;
		    	motor[rightMotor] = 0;
				}
				wait1Msec(abs(right-left)*5);
				stopMovement();
				moveForward();
			} else {
				moveForward();
			}
			//findPath(&distance, &distanceIndex, &light, &lightIndex);
			//writeDebugStream("%d %d %d %d\n",distance, distanceIndex, light, lightIndex);
			/*else if (distanceIndex != NULL) {
					if (distanceIndex < 0) {
						// negative / turn right
					  motor[leftMotor]  = 75;
		    		motor[rightMotor] = -75;
					} else {
						// positive / turn left
					  motor[leftMotor]  = -75;
		    		motor[rightMotor] = 75;
					}
					sleep(abs(distanceIndex)*7);
					stopMovement();
					wait1Msec(1000);
					moveForward();
					stopMovement();
			} else {
				moveReverse();
				turnLeft();
			}*/
		}
		wait1Msec(2000);
	}
}
