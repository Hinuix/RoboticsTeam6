#pragma config(Sensor, in1,    lightSensor,    sensorReflection)
#pragma config(Sensor, dgtl1,  sonarInput,     sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  leftLimitSwitch, sensorTouch)
#pragma config(Sensor, dgtl6,  rightLimitSwitch, sensorTouch)
#pragma config(Sensor, dgtl10, bumpLeft,       sensorTouch)
#pragma config(Sensor, dgtl11, bumpRight,      sensorTouch)
#pragma config(Motor,  port2,           rightMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           myServo,       tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define ServoWaitTime 750
#define nSamples 3
#define MotorTurnTime 710
#define ForwardTurn 65
#define BackwardTurn -55
#define MotorForwardTime 700
#define MotorForwardSpeed 70
#define MotorReverseTime 700
#define MotorReverseSpeed -60
#define ThresholdDistance 20

/*
 * stopMovement: sets the motion of the robot's wheels to zero
 * paramters: none
*/
void stopMovement() {
	motor[leftMotor] = motor[rightMotor] = 0;
}

/*
 * sampleDistance: samples nSamples times and returns the average reading
 * of the ultrasonic sensor
 * paramters: none
 * returns (int) avg / nSamples
*/
int sampleDistance() {
	int avg = 0;
	for (int i = 0; i < nSamples; i++) {
		avg += SensorValue(sonarInput); // Sample Sonar
	}
	return avg / nSamples;
}

int findPath() {
	// Set servo to initial position and wait for it to get there
	motor[myServo] = -127;
	sleep(1000);

	// Declare some variables for later
	int max = -1;
	int maxIndex = -1;
	int distance;
	// loop through possible positions for light sensor
	for (int i = -127; i < 128; i+=2) {
		// set position
		motor[myServo] = i;
		sleep(40);
		// take reading
		distance = sampleDistance();
		// adjust position of the strongest light source if needed
		if (distance > max) {
			max = distance;
			maxIndex = i;
		}
	}
	if (max > 20) {
		return maxIndex;
	} else {
		return NULL;
	}
}

/*
 * findLight: samples lightSensor values at every position for our servo and returns the
 * servo position where the strongest light source is
 * paramters: none
 * returns (int) minIndex/servo position where light is strongest
*/
int findLight() {
	// Set servo to initial position and wait for it to get there
	motor[myServo] = -127;
	sleep(1000);

	// Declare some variables for later
	int min = 2000;
	int minIndex = -1;
	int sensorValue;
	// loop through possible positions for light sensor
	for (int i = -127; i < 128; i+=5) {
		// set position
		motor[myServo] = i;
		sleep(20);
		// take reading
		sensorValue = SensorValue(lightSensor);
		// adjust position of the strongest light source if needed
		if (sensorValue < min) {
			min = sensorValue;
			minIndex = i;
		}
	}
	writeDebugStream("Min Light Value: %d | Min Index: %d\n",min,minIndex);
	if (min < 300) {
		return minIndex;
	} else {
		return NULL;
	}
}

/*
 * sampleLimitValue: samples left and right limit switches
 * paramters: none
 * returns (int) 1 if either one is pressed
 * returns (int) 0 if they are not pressed
*/
int sampleLimitValue() {
	int leftLimit = SensorValue(leftLimitSwitch);
	int rightLimit = SensorValue(rightLimitSwitch);

	if(rightLimit == 1 | leftLimit == 1) {
		return(1);
	}
	else {
		return(0);
	}
}

/*
 * sampleBumpValue: samples left and right bump switches
 * paramters: none
 * returns (int) 1 if either one is pressed
 * returns (int) 0 if they are not pressed
*/
int sampleBumpValue() {
	int leftBump = SensorValue(bumpLeft);
	int rightBump = SensorValue(bumpRight);

	if(rightBump == 1 | leftBump == 1) {
		return(1);
	}
	else {
		return(0);
	}
}

/*
 * lookRight: measure the distance to the right of the robot
 * by moving the light sensor via the servo assembly to the right
 * side of the robot and calling sampleDistance() to get a reading
 * from the ultrasonic sensor
 * paramters: none
 * returns (int) distance
*/
int lookRight() {
	// Variable Declarations
	int distance;

	// Functionality
	motor[myServo] = -127;
	wait1Msec(ServoWaitTime);
	distance = sampleDistance();
	motor[myServo] = 0;
	wait1Msec(ServoWaitTime);
	return distance;
}

/*
 * lookLeft: measure the distance to the right of the robot
 * by moving the light sensor via the servo assembly to the left
 * side of the robot and calling sampleDistance() to get a reading
 * from the ultrasonic sensor
 * paramters: none
 * returns (int) distance
*/
int lookLeft() {
	// Variable Declarations
	int distance;

	// Functionality
	motor[myServo] = 127;
	wait1Msec(ServoWaitTime);
	distance = sampleDistance();
	motor[myServo] = 0;
	wait1Msec(ServoWaitTime);
	return distance;
}

/*
 * lookFoward: measures the distance forward by first looking left
 * to calibrate the forward measurement and then resamples the distance
 * and returns that value
 * paramters: none
 * returns (int) distance
*/
int lookForward() {
	// Variable Declarations
	int distance;

	// Functionality
	distance = lookLeft();
	distance = sampleDistance();
	return distance;
}

/*
 * moveForward: sets the motion of the robot to
 * the set MotorForwardSpeed constant for MotorForwardTime milliseconds
 * and then stops
 * paramters: none
*/void moveForward() {
	motor[rightMotor] = (int)((float)MotorForwardSpeed * 1.1);
	motor[leftMotor] = MotorForwardSpeed;
	wait1Msec(MotorForwardTime);
	stopMovement();
}

/*
 * turnRight: sets the motion of the left motor to the constant
 * ForwardTurn and sets the motion of the right motor to BackwardTurn
 * and then stops motion by calling stopMovement()
 * paramters: none
*/
void turnRight() {
	motor[leftMotor] = ForwardTurn;
	motor[rightMotor] = BackwardTurn;
	wait1Msec(MotorTurnTime);
	stopMovement();
}

/*
 * turnLeft: sets the motion of the right motor to the constant
 * ForwardTurn and sets the motion of the left motor to BackwardTurn
 * and then stops motion by calling stopMovement()
 * paramters: none
*/
void turnLeft() {
	motor[leftMotor] = BackwardTurn;
	motor[rightMotor] = ForwardTurn;
	wait1Msec(MotorTurnTime);
	stopMovement();
}

/*
 * moveReverse: sets the motion of the robot to
 * the set MotorReverseSpeed constant for MotorReverseTime milliseconds
 * and then stops
 * paramters: none
*/
void moveReverse() {
	motor[leftMotor] = motor[rightMotor] = MotorReverseSpeed;
	wait1Msec(MotorReverseTime);
	stopMovement();
}

void turnAround(int leftDistance, int rightDistance) {
	moveReverse();
	if (rightDistance > ThresholdDistance != leftDistance > ThresholdDistance) { // logical XOR
		if (rightDistance > ThresholdDistance) {
			turnRight();
		} else {
			turnLeft();
		}
	} else {
		// Turn Around
		if (rightDistance > leftDistance) {
			turnRight();
			sleep(100);
			turnRight();
		} else {
			turnLeft();
			sleep(100);
			turnLeft();
		}
	}
}


task main()
{
	sleep(5000);
	int distance;
	moveForward();
	// Maze Search Algorithm
	while (true) {
		// Uncomment to test Calibration of ultrasonic sensor
		// and the right and left DC motors
		/*
		writeDebugStream("Right Distance: %d\n", lookRight());
		writeDebugStream("Front Distance: %d\n", lookForward());
		writeDebugStream("Left Distance: %d\n", lookLeft());
		sleep(3000);
		moveForward();
		wait1Msec(1000);
		turnLeft();
		wait1Msec(1000);
		turnRight();
		wait1Msec(1000);
		moveReverse();
		sleep(10000);


		//writeDebugStream("bumbPressed?: %d\n", sampleBumpValue());
		//writeDebugStream("limitPressed?: %d\n", sampleLimitValue());
		writeDebugStream("minIndexForLight: %d\n", findLight());
		//sleep(abs(lightPosition)*2); **Use this for findLight()**
		sleep(3000);
		*/
		// END CALIBRATION CODE

		/*int rightDistance = lookRight();
		int leftDistance = lookLeft();
		int forwardDistance = lookForward();
		// BEGIN MAZE TRAVERSAL ALGORITHM
		if ((distance = sampleDistance()) < ThresholdDistance || sampleBumpValue()) {
			// Obstacle ahead, turn around
			turnAround(leftDistance, rightDistance);
		} else {
			// Move Forward, look for turns
			if (rightDistance > 60) {
				// Turn Right, there is space
				turnRight();
			} else if (leftDistance > 60) {
				// Turn Left, there is space
				turnLeft();
			}
			moveForward();
		}
		sleep(1000);*/
		int index = findPath();
		if (index != NULL) {
			//turn index light
			if (index < 0) {
				// negative / turn right
			  motor[leftMotor]  = 75;
    		motor[rightMotor] = -75;
			} else {
				// positive / turn left
			  motor[leftMotor]  = -75;
    		motor[rightMotor] = 75;
			}
			sleep(abs(index)*4);
			stopMovement();
			moveForward();
			stopMovement();
			if (sampleBumpValue()) {
				moveReverse();
			}
		} else {
			turnRight();
		}
	}
}
